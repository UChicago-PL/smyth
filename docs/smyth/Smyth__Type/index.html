<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Smyth__Type (smyth.Smyth__Type)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">smyth</a> &#x00BB; Smyth__Type</nav><h1>Module <code>Smyth__Type</code></h1><p>Type helpers and type-checking.</p><nav class="toc"><ul><li><a href="#helpers">Helpers</a></li><li><a href="#substitution">Substitution</a></li><li><a href="#typechecking">Type-checking</a></li></ul></nav></header><section><header><h2 id="helpers"><a href="#helpers" class="anchor"></a>Helpers</h2></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal tau1 tau2</code> determines if <code>tau1</code> and <code>tau2</code> have the same abstract syntax tree.</p></dd></dl><dl><dt class="spec value" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span class="keyword">val</span> wildcard : <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></dt><dd><p>The &quot;wildcard&quot; type.</p></dd></dl><dl><dt class="spec value" id="val-matches"><a href="#val-matches" class="anchor"></a><code><span class="keyword">val</span> matches : <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>matches tau1 tau2</code> determines if <code>tau1</code> and <code>tau2</code> have the same abstract syntax tree modulo any wildcards.</p></dd></dl><dl><dt class="spec value" id="val-is_base"><a href="#val-is_base" class="anchor"></a><code><span class="keyword">val</span> is_base : <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_base tau</code> returns determines if <code>tau</code> is a base type.</p></dd></dl><dl><dt class="spec value" id="val-domain_of_codomain"><a href="#val-domain_of_codomain" class="anchor"></a><code><span class="keyword">val</span> domain_of_codomain : <span>codomain:<a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></span> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <span><a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> option</span></code></dt><dd><p><code>domain_of_codomain ~codomain root</code> looks for <code>codomain</code> on the right-hand side of a type arrow in <code>root</code> that is not on the left-hand side of any type arrow and, if found, returns the left-hand side of that type arrow.</p><p>For example, suppose <code>tau = a -&gt; (b -&gt; (c -&gt; d))</code>. Then:</p><pre><code class="ml">domain_of_codomain ~codomain:d tau = Some c
domain_of_codomain ~codomain:(c -&gt; d) tau = Some b
domain_of_codomain ~codomain:(b -&gt; (c -&gt; d)) tau = Some a
domain_of_codomain ~codomain:(a -&gt; (b -&gt; (c -&gt; d))) tau = None</code></pre><p>Also:</p><pre><code class="ml">domain_of_codomain ~codomain:a a = None
domain_of_codomain ~codomain:a (() -&gt; a) = Some ()</code></pre></dd></dl><dl><dt class="spec value" id="val-bind_spec"><a href="#val-bind_spec" class="anchor"></a><code><span class="keyword">val</span> bind_spec : <a href="../Smyth/Lang/index.html#type-type_ctx">Smyth.Lang.type_ctx</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-bind_spec">Smyth.Lang.bind_spec</a></code></dt><dd><p><code>bind_spec gamma e</code> returns the computed binding specification of <code>e</code> with respect to <code>gamma</code>. In particular:</p><ul><li>Projections decrease the binding specification of their argument</li><li>Variables are looked up in <code>gamma</code></li></ul></dd></dl><dl><dt class="spec value" id="val-sub_bind_spec"><a href="#val-sub_bind_spec" class="anchor"></a><code><span class="keyword">val</span> sub_bind_spec : <a href="../Smyth/Lang/index.html#type-bind_spec">Smyth.Lang.bind_spec</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-bind_spec">Smyth.Lang.bind_spec</a></code></dt><dd><p><code>sub_bind_spec b</code> &quot;decreases&quot; the binding specification <code>b</code>. In particular, if <code>b</code> is a binding specification for the argument of some function, then <code>sub_bind_spec b</code> will be a binding specification for <i>decreasing</i> on that function.</p></dd></dl><dl><dt class="spec value" id="val-structurally_decreasing_bind_spec"><a href="#val-structurally_decreasing_bind_spec" class="anchor"></a><code><span class="keyword">val</span> structurally_decreasing_bind_spec : <span>head_spec:<a href="../Smyth/Lang/index.html#type-bind_spec">Smyth.Lang.bind_spec</a></span> <span>&#45;&gt;</span> <span>arg_spec:<a href="../Smyth/Lang/index.html#type-bind_spec">Smyth.Lang.bind_spec</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>structurally_decreasing_bind_spec ~head_spec ~arg_spec</code> determines if <code>arg_spec</code> is decreasing on <code>head_spec</code>. If <code>head_spec</code> is not a binding specification for a recursive function, then <code>structurally_decreasing ~head_spec ~arg_spec</code> will return <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-structurally_decreasing"><a href="#val-structurally_decreasing" class="anchor"></a><code><span class="keyword">val</span> structurally_decreasing : <a href="../Smyth/Lang/index.html#type-type_ctx">Smyth.Lang.type_ctx</a> <span>&#45;&gt;</span> <span>head:<a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a></span> <span>&#45;&gt;</span> <span>arg:<a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>structurally_decreasing gamma ~head ~arg</code> determines if <code>arg</code> is structurally decreasing on <code>head</code> in the context <code>gamma</code>.</p></dd></dl><dl><dt class="spec value" id="val-matches_dec"><a href="#val-matches_dec" class="anchor"></a><code><span class="keyword">val</span> matches_dec : <span>string option</span> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-bind_spec">Smyth.Lang.bind_spec</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>matches_dec (Some f) bind_spec</code> determines if <code>bind_spec</code> is structurally decreasing on the recursive function <code>f</code>. <code>matches_dec None bind_spec</code> will always return <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-peel_forall"><a href="#val-peel_forall" class="anchor"></a><code><span class="keyword">val</span> peel_forall : <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <span>string list</span> * <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></dt><dd><p>Peels all outer universal quantifiers on a type into a list. For example:</p><pre><code class="ml">peel_forall (forall a . forall b . a * b) = ([&quot;a&quot;, &quot;b&quot;], a * b)
peel_forall a = ([], a)
peel_forall (int * int) = ([], int * int)
peel_forall (forall c . int) = ([&quot;c&quot;], int)
peel_forall (forall c . d) = ([&quot;c&quot;], d)</code></pre></dd></dl></section><section><header><h2 id="substitution"><a href="#substitution" class="anchor"></a>Substitution</h2></header><dl><dt class="spec value" id="val-substitute"><a href="#val-substitute" class="anchor"></a><code><span class="keyword">val</span> substitute : <span>before:string</span> <span>&#45;&gt;</span> <span>after:<a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></span> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></dt><dd><p><code>substitute ~before ~after tau</code> substitutes replaces free occurrences of <code>before</code> in <code>tau</code> with <code>after</code>.</p></dd></dl><dl><dt class="spec value" id="val-substitute_many"><a href="#val-substitute_many" class="anchor"></a><code><span class="keyword">val</span> substitute_many : <span>bindings:<span><span>(string * <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a>)</span> list</span></span> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></dt><dd><p>Performs many substitutions one after another; see <a href="index.html#val-substitute"><code>substitute</code></a>.</p></dd></dl></section><section><header><h2 id="typechecking"><a href="#typechecking" class="anchor"></a>Type-checking</h2><p>The following functions implement a bidirectional type checker.</p></header><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code><code> = </code><table class="variant"><tr id="type-error.VarNotFound" class="anchored"><td class="def constructor"><a href="#type-error.VarNotFound" class="anchor"></a><code>| </code><code><span class="constructor">VarNotFound</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-error.CtorNotFound" class="anchored"><td class="def constructor"><a href="#type-error.CtorNotFound" class="anchor"></a><code>| </code><code><span class="constructor">CtorNotFound</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-error.PatternMatchFailure" class="anchored"><td class="def constructor"><a href="#type-error.PatternMatchFailure" class="anchor"></a><code>| </code><code><span class="constructor">PatternMatchFailure</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> * <a href="../Smyth/Lang/index.html#type-pat">Smyth.Lang.pat</a></code></td></tr><tr id="type-error.WrongNumberOfTypeArguments" class="anchored"><td class="def constructor"><a href="#type-error.WrongNumberOfTypeArguments" class="anchor"></a><code>| </code><code><span class="constructor">WrongNumberOfTypeArguments</span> <span class="keyword">of</span> int * int</code></td></tr><tr id="type-error.GotFunctionButExpected" class="anchored"><td class="def constructor"><a href="#type-error.GotFunctionButExpected" class="anchor"></a><code>| </code><code><span class="constructor">GotFunctionButExpected</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.GotTupleButExpected" class="anchored"><td class="def constructor"><a href="#type-error.GotTupleButExpected" class="anchor"></a><code>| </code><code><span class="constructor">GotTupleButExpected</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.GotTypeAbstractionButExpected" class="anchored"><td class="def constructor"><a href="#type-error.GotTypeAbstractionButExpected" class="anchor"></a><code>| </code><code><span class="constructor">GotTypeAbstractionButExpected</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.GotButExpected" class="anchored"><td class="def constructor"><a href="#type-error.GotButExpected" class="anchor"></a><code>| </code><code><span class="constructor">GotButExpected</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> * <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.BranchMismatch" class="anchored"><td class="def constructor"><a href="#type-error.BranchMismatch" class="anchor"></a><code>| </code><code><span class="constructor">BranchMismatch</span> <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.CannotInferFunctionType" class="anchored"><td class="def constructor"><a href="#type-error.CannotInferFunctionType" class="anchor"></a><code>| </code><code><span class="constructor">CannotInferFunctionType</span></code></td></tr><tr id="type-error.CannotInferCaseType" class="anchored"><td class="def constructor"><a href="#type-error.CannotInferCaseType" class="anchor"></a><code>| </code><code><span class="constructor">CannotInferCaseType</span></code></td></tr><tr id="type-error.CannotInferHoleType" class="anchored"><td class="def constructor"><a href="#type-error.CannotInferHoleType" class="anchor"></a><code>| </code><code><span class="constructor">CannotInferHoleType</span></code></td></tr><tr id="type-error.ExpectedArrowButGot" class="anchored"><td class="def constructor"><a href="#type-error.ExpectedArrowButGot" class="anchor"></a><code>| </code><code><span class="constructor">ExpectedArrowButGot</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.ExpectedTupleButGot" class="anchored"><td class="def constructor"><a href="#type-error.ExpectedTupleButGot" class="anchor"></a><code>| </code><code><span class="constructor">ExpectedTupleButGot</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.ExpectedForallButGot" class="anchored"><td class="def constructor"><a href="#type-error.ExpectedForallButGot" class="anchor"></a><code>| </code><code><span class="constructor">ExpectedForallButGot</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.ExpectedDatatypeButGot" class="anchored"><td class="def constructor"><a href="#type-error.ExpectedDatatypeButGot" class="anchor"></a><code>| </code><code><span class="constructor">ExpectedDatatypeButGot</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.TupleLengthMismatch" class="anchored"><td class="def constructor"><a href="#type-error.TupleLengthMismatch" class="anchor"></a><code>| </code><code><span class="constructor">TupleLengthMismatch</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.ProjectionLengthMismatch" class="anchored"><td class="def constructor"><a href="#type-error.ProjectionLengthMismatch" class="anchor"></a><code>| </code><code><span class="constructor">ProjectionLengthMismatch</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr><tr id="type-error.ProjectionOutOfBounds" class="anchored"><td class="def constructor"><a href="#type-error.ProjectionOutOfBounds" class="anchor"></a><code>| </code><code><span class="constructor">ProjectionOutOfBounds</span> <span class="keyword">of</span> int * int</code></td></tr><tr id="type-error.TypeAbstractionParameterNameMismatch" class="anchored"><td class="def constructor"><a href="#type-error.TypeAbstractionParameterNameMismatch" class="anchor"></a><code>| </code><code><span class="constructor">TypeAbstractionParameterNameMismatch</span> <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.AssertionTypeMismatch" class="anchored"><td class="def constructor"><a href="#type-error.AssertionTypeMismatch" class="anchor"></a><code>| </code><code><span class="constructor">AssertionTypeMismatch</span> <span class="keyword">of</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> * <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a></code></td></tr></table></dt><dd><p>Type-checking errors.</p></dd></dl><dl><dt class="spec value" id="val-check"><a href="#val-check" class="anchor"></a><code><span class="keyword">val</span> check : <a href="../Smyth/Lang/index.html#type-datatype_ctx">Smyth.Lang.datatype_ctx</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-type_ctx">Smyth.Lang.type_ctx</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> <span>&#45;&gt;</span> <span><span>(<a href="../Smyth/Lang/index.html#type-hole_ctx">Smyth.Lang.hole_ctx</a>, <a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a> * <a href="index.html#type-error">error</a>)</span> Stdlib.result</span></code></dt><dd><p>Bidirectional type &quot;checking&quot;.</p></dd></dl><dl><dt class="spec value" id="val-infer"><a href="#val-infer" class="anchor"></a><code><span class="keyword">val</span> infer : <a href="../Smyth/Lang/index.html#type-datatype_ctx">Smyth.Lang.datatype_ctx</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-type_ctx">Smyth.Lang.type_ctx</a> <span>&#45;&gt;</span> <a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a> <span>&#45;&gt;</span> <span><span>(<a href="../Smyth/Lang/index.html#type-typ">Smyth.Lang.typ</a> * <a href="../Smyth/Lang/index.html#type-hole_ctx">Smyth.Lang.hole_ctx</a>, <a href="../Smyth/Lang/index.html#type-exp">Smyth.Lang.exp</a> * <a href="index.html#type-error">error</a>)</span> Stdlib.result</span></code></dt><dd><p>Bidirectional type &quot;inference&quot; or &quot;synthesis&quot;.</p></dd></dl></section></div></body></html>